--- Multi App ---
The connector must track all installed user apps, and not allow any user to access another user's app.
This means the user session must include all app data -
private key, app id, client id, client secret, webhook secret
in addition to installation id.

If an unauthenticated user tries to access the connector
- if the connector has had an app set up, then they can set up
- else, access has to be denied, or the user must prove they own the app somehow (enter the client secret, or PEM as a password?)



--- One App ---

The connector has its own app and must know its own private key, app ID, client ID, client secret, and webhook secret

We open the github.com/<slug>/installation page which the user can install from

the app call back with an installation ID

The installation ID is unique to the user, so that is what we can use to create the cookie.
The session is uniquely identified with the installation ID.
The cookie could be signed with the app private key but it's safer to use something different

However. in the one app case, the connector does not run inside the user cluster, it runs in the hosting cluster.
so, it's not so easy to access the k8s resources. the user would have to log into openshift from the app and we'd have to store that state too.
this would also present firewall problems.


OAuth vs non-OAuth

OAuth
- <user> did thing <using the app>
- need to store client_id, client_secret, access_token, and refresh_token
  - client_* server side, *_token client side
  - and a cookie which identifies the client_id/secret for a user

No Oauth
- <app> did thing
- need to store app id and pem on server side
- need a cookie which identifies the user's app, mapping a user session to the app secrets.
